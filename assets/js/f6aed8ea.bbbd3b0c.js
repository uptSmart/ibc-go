"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8487],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>u});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},h="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=c(t),p=i,u=h["".concat(l,".").concat(p)]||h[p]||m[p]||r;return t?a.createElement(u,o(o({ref:n},d),{},{components:t})):a.createElement(u,o({ref:n},d))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=p;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[h]="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=t[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},28146:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=t(87462),i=(t(67294),t(3905));const r={},o="ADR 001: Coin Source Tracing",s={unversionedId:"adr-001-coin-source-tracing",id:"adr-001-coin-source-tracing",title:"ADR 001: Coin Source Tracing",description:"Changelog",source:"@site/architecture/adr-001-coin-source-tracing.md",sourceDirName:".",slug:"/adr-001-coin-source-tracing",permalink:"/architecture/adr-001-coin-source-tracing",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Architecture Decision Records (ADR)",permalink:"/architecture/"},next:{title:"ADR 002: Go module versioning",permalink:"/architecture/adr-002-go-module-versioning"}},l={},c=[{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Example",id:"example",level:3},{value:"Problem",id:"problem",level:3},{value:"Decision",id:"decision",level:2},{value:"<code>x/ibc-transfer</code> Changes",id:"xibc-transfer-changes",level:3},{value:"Coin Changes",id:"coin-changes",level:3},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"References",id:"references",level:2}],d={toc:c},h="wrapper";function m(e){let{components:n,...t}=e;return(0,i.kt)(h,(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"adr-001-coin-source-tracing"},"ADR 001: Coin Source Tracing"),(0,i.kt)("h2",{id:"changelog"},"Changelog"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"2020-07-09: Initial Draft"),(0,i.kt)("li",{parentName:"ul"},"2020-08-11: Implementation changes")),(0,i.kt)("h2",{id:"status"},"Status"),(0,i.kt)("p",null,"Accepted, Implemented"),(0,i.kt)("h2",{id:"context"},"Context"),(0,i.kt)("p",null,"The specification for IBC cross-chain fungible token transfers\n(",(0,i.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc/tree/master/spec/app/ics-020-fungible-token-transfer"},"ICS20"),"), needs to\nbe aware of the origin of any token denomination in order to relay a ",(0,i.kt)("inlineCode",{parentName:"p"},"Packet")," which contains the sender\nand recipient addressed in the\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc/tree/master/spec/app/ics-020-fungible-token-transfer#data-structures"},(0,i.kt)("inlineCode",{parentName:"a"},"FungibleTokenPacketData")),"."),(0,i.kt)("p",null,"The Packet relay sending works based in 2 cases (per\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc/tree/master/spec/app/ics-020-fungible-token-transfer#packet-relay"},"specification")," and ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/colin-axner"},"Colin Axn\xe9r"),"'s description):"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Sender chain is acting as the source zone. The coins are transferred\nto an escrow address (i.e locked) on the sender chain and then transferred\nto the receiving chain through IBC TAO logic. It is expected that the\nreceiving chain will mint vouchers to the receiving address.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Sender chain is acting as the sink zone. The coins (vouchers) are burned\non the sender chain and then transferred to the receiving chain though IBC\nTAO logic. It is expected that the receiving chain, which had previously\nsent the original denomination, will unescrow the fungible token and send\nit to the receiving address."))),(0,i.kt)("p",null,"Another way of thinking of source and sink zones is through the token's\ntimeline. Each send to any chain other than the one it was previously\nreceived from is a movement forwards in the token's timeline. This causes\ntrace to be added to the token's history and the destination port and\ndestination channel to be prefixed to the denomination. In these instances\nthe sender chain is acting as the source zone. When the token is sent back\nto the chain it previously received from, the prefix is removed. This is\na backwards movement in the token's timeline and the sender chain\nis acting as the sink zone."),(0,i.kt)("h3",{id:"example"},"Example"),(0,i.kt)("p",null,"Assume the following channel connections exist and that all channels use the port ID ",(0,i.kt)("inlineCode",{parentName:"p"},"transfer"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"chain ",(0,i.kt)("inlineCode",{parentName:"li"},"A")," has channels with chain ",(0,i.kt)("inlineCode",{parentName:"li"},"B")," and chain ",(0,i.kt)("inlineCode",{parentName:"li"},"C")," with the IDs ",(0,i.kt)("inlineCode",{parentName:"li"},"channelToB")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"channelToC"),", respectively"),(0,i.kt)("li",{parentName:"ul"},"chain ",(0,i.kt)("inlineCode",{parentName:"li"},"B")," has channels with chain ",(0,i.kt)("inlineCode",{parentName:"li"},"A")," and chain ",(0,i.kt)("inlineCode",{parentName:"li"},"C")," with the IDs ",(0,i.kt)("inlineCode",{parentName:"li"},"channelToA")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"channelToC"),", respectively"),(0,i.kt)("li",{parentName:"ul"},"chain ",(0,i.kt)("inlineCode",{parentName:"li"},"C")," has channels with chain ",(0,i.kt)("inlineCode",{parentName:"li"},"A")," and chain ",(0,i.kt)("inlineCode",{parentName:"li"},"B")," with the IDs ",(0,i.kt)("inlineCode",{parentName:"li"},"channelToA")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"channelToB"),", respectively")),(0,i.kt)("p",null,"These steps of transfer between chains occur in the following order: ",(0,i.kt)("inlineCode",{parentName:"p"},"A -> B -> C -> A -> C"),". In particular:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"A -> B"),": sender chain is source zone. ",(0,i.kt)("inlineCode",{parentName:"li"},"A")," sends packet with ",(0,i.kt)("inlineCode",{parentName:"li"},"denom")," (escrowed on ",(0,i.kt)("inlineCode",{parentName:"li"},"A"),"), ",(0,i.kt)("inlineCode",{parentName:"li"},"B")," receives ",(0,i.kt)("inlineCode",{parentName:"li"},"denom")," and mints and sends voucher ",(0,i.kt)("inlineCode",{parentName:"li"},"transfer/channelToA/denom")," to recipient."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"B -> C"),": sender chain is source zone. ",(0,i.kt)("inlineCode",{parentName:"li"},"B")," sends packet with ",(0,i.kt)("inlineCode",{parentName:"li"},"transfer/channelToA/denom")," (escrowed on ",(0,i.kt)("inlineCode",{parentName:"li"},"B"),"), ",(0,i.kt)("inlineCode",{parentName:"li"},"C")," receives ",(0,i.kt)("inlineCode",{parentName:"li"},"transfer/channelToA/denom")," and mints and sends voucher ",(0,i.kt)("inlineCode",{parentName:"li"},"transfer/channelToB/transfer/channelToA/denom")," to recipient."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"C -> A"),": sender chain is source zone. ",(0,i.kt)("inlineCode",{parentName:"li"},"C")," sends packet with ",(0,i.kt)("inlineCode",{parentName:"li"},"transfer/channelToB/transfer/channelToA/denom")," (escrowed on ",(0,i.kt)("inlineCode",{parentName:"li"},"C"),"), ",(0,i.kt)("inlineCode",{parentName:"li"},"A")," receives ",(0,i.kt)("inlineCode",{parentName:"li"},"transfer/channelToB/transfer/channelToA/denom")," and mints and sends voucher ",(0,i.kt)("inlineCode",{parentName:"li"},"transfer/channelToC/transfer/channelToB/transfer/channelToA/denom")," to recipient."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"A -> C"),": sender chain is sink zone. ",(0,i.kt)("inlineCode",{parentName:"li"},"A")," sends packet with ",(0,i.kt)("inlineCode",{parentName:"li"},"transfer/channelToC/transfer/channelToB/transfer/channelToA/denom")," (burned on ",(0,i.kt)("inlineCode",{parentName:"li"},"A"),"), ",(0,i.kt)("inlineCode",{parentName:"li"},"C")," receives ",(0,i.kt)("inlineCode",{parentName:"li"},"transfer/channelToC/transfer/channelToB/transfer/channelToA/denom"),", and unescrows and sends ",(0,i.kt)("inlineCode",{parentName:"li"},"transfer/channelToB/transfer/channelToA/denom")," to recipient.")),(0,i.kt)("p",null,"The token has a final denomination on chain ",(0,i.kt)("inlineCode",{parentName:"p"},"C")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"transfer/channelToB/transfer/channelToA/denom"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"transfer/channelToB/transfer/channelToA")," is the trace information."),(0,i.kt)("p",null,"In this context, upon a receive of a cross-chain fungible token transfer, if the sender chain is the source of the token, the protocol prefixes the denomination with the port and channel identifiers in the following format:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"prefix + denom = {destPortN}/{destChannelN}/.../{destPort0}/{destChannel0}/denom\n")),(0,i.kt)("p",null,"Example: transferring ",(0,i.kt)("inlineCode",{parentName:"p"},"100 uatom")," from port ",(0,i.kt)("inlineCode",{parentName:"p"},"HubPort")," and channel ",(0,i.kt)("inlineCode",{parentName:"p"},"HubChannel")," on the Hub to\nEthermint's port ",(0,i.kt)("inlineCode",{parentName:"p"},"EthermintPort")," and channel ",(0,i.kt)("inlineCode",{parentName:"p"},"EthermintChannel")," results in ",(0,i.kt)("inlineCode",{parentName:"p"},"100\nEthermintPort/EthermintChannel/uatom"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"EthermintPort/EthermintChannel/uatom")," is the new\ndenomination on the receiving chain."),(0,i.kt)("p",null,"In the case those tokens are transferred back to the Hub (i.e the ",(0,i.kt)("strong",{parentName:"p"},"source")," chain), the prefix is\ntrimmed and the token denomination updated to the original one."),(0,i.kt)("h3",{id:"problem"},"Problem"),(0,i.kt)("p",null,"The problem of adding additional information to the coin denomination is twofold:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The ever increasing length if tokens are transferred to zones other than the source:")),(0,i.kt)("p",null,"If a token is transferred ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," times via IBC to a sink chain, the token denom will contain ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," pairs\nof prefixes, as shown on the format example above. This poses a problem because, while port and\nchannel identifiers have a maximum length of 64 each, the SDK ",(0,i.kt)("inlineCode",{parentName:"p"},"Coin")," type only accepts denoms up to\n64 characters. Thus, a single cross-chain token, which again, is composed by the port and channels\nidentifiers plus the base denomination, can exceed the length validation for the SDK ",(0,i.kt)("inlineCode",{parentName:"p"},"Coins"),"."),(0,i.kt)("p",null,"This can result in undesired behaviours such as tokens not being able to be transferred to multiple\nsink chains if the denomination exceeds the length or unexpected ",(0,i.kt)("inlineCode",{parentName:"p"},"panics")," due to denomination\nvalidation failing on the receiving chain."),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},"The existence of special characters and uppercase letters on the denomination:")),(0,i.kt)("p",null,"In the SDK every time a ",(0,i.kt)("inlineCode",{parentName:"p"},"Coin")," is initialized through the constructor function ",(0,i.kt)("inlineCode",{parentName:"p"},"NewCoin"),", a validation\nof a coin's denom is performed according to a\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/blob/a940214a4923a3bf9a9161cd14bd3072299cd0c9/types/coin.go#L583"},"Regex"),",\nwhere only lowercase alphanumeric characters are accepted. While this is desirable for native denominations\nto keep a clean UX, it presents a challenge for IBC as ports and channels might be randomly\ngenerated with special and uppercase characters as per the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc/tree/master/spec/core/ics-024-host-requirements#paths-identifiers-separators"},"ICS 024 - Host\nRequirements"),"\nspecification."),(0,i.kt)("h2",{id:"decision"},"Decision"),(0,i.kt)("p",null,"The issues outlined above, are applicable only to SDK-based chains, and thus the proposed solution\nare do not require specification changes that would result in modification to other implementations\nof the ICS20 spec."),(0,i.kt)("p",null,"Instead of adding the identifiers on the coin denomination directly, the proposed solution hashes\nthe denomination prefix in order to get a consistent length for all the cross-chain fungible tokens."),(0,i.kt)("p",null,"This will be used for internal storage only, and when transferred via IBC to a different chain, the\ndenomination specified on the packed data will be the full prefix path of the identifiers needed to\ntrace the token back to the originating chain, as specified on ICS20."),(0,i.kt)("p",null,"The new proposed format will be the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'ibcDenom = "ibc/" + hash(trace path + "/" + base denom)\n')),(0,i.kt)("p",null,"The hash function will be a SHA256 hash of the fields of the ",(0,i.kt)("inlineCode",{parentName:"p"},"DenomTrace"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-protobuf"},"// DenomTrace contains the base denomination for ICS20 fungible tokens and the source tracing\n// information\nmessage DenomTrace {\n  // chain of port/channel identifiers used for tracing the source of the fungible token\n  string path = 1;\n  // base denomination of the relayed fungible token\n  string base_denom = 2;\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"IBCDenom")," function constructs the ",(0,i.kt)("inlineCode",{parentName:"p"},"Coin")," denomination used when creating the ICS20 fungible token packet data:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'// Hash returns the hex bytes of the SHA256 hash of the DenomTrace fields using the following formula:\n//\n// hash = sha256(tracePath + "/" + baseDenom)\nfunc (dt DenomTrace) Hash() tmbytes.HexBytes {\n  return tmhash.Sum(dt.Path + "/" + dt.BaseDenom)\n}\n\n// IBCDenom a coin denomination for an ICS20 fungible token in the format \'ibc/{hash(tracePath + baseDenom)}\'. \n// If the trace is empty, it will return the base denomination.\nfunc (dt DenomTrace) IBCDenom() string {\n  if dt.Path != "" {\n    return fmt.Sprintf("ibc/%s", dt.Hash())\n  }\n  return dt.BaseDenom\n}\n')),(0,i.kt)("h3",{id:"xibc-transfer-changes"},(0,i.kt)("inlineCode",{parentName:"h3"},"x/ibc-transfer")," Changes"),(0,i.kt)("p",null,"In order to retrieve the trace information from an IBC denomination, a lookup table needs to be\nadded to the ",(0,i.kt)("inlineCode",{parentName:"p"},"ibc-transfer")," module. These values need to also be persisted between upgrades, meaning\nthat a new ",(0,i.kt)("inlineCode",{parentName:"p"},"[]DenomTrace")," ",(0,i.kt)("inlineCode",{parentName:"p"},"GenesisState")," field state needs to be added to the module:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"// GetDenomTrace retrieves the full identifiers trace and base denomination from the store.\nfunc (k Keeper) GetDenomTrace(ctx Context, denomTraceHash []byte) (DenomTrace, bool) {\n  store := ctx.KVStore(k.storeKey)\n  bz := store.Get(types.KeyDenomTrace(traceHash))\n  if bz == nil {\n    return &DenomTrace, false\n  }\n\n  var denomTrace DenomTrace\n  k.cdc.MustUnmarshalBinaryBare(bz, &denomTrace)\n  return denomTrace, true\n}\n\n// HasDenomTrace checks if a the key with the given trace hash exists on the store.\nfunc (k Keeper) HasDenomTrace(ctx Context, denomTraceHash []byte)  bool {\n  store := ctx.KVStore(k.storeKey)\n  return store.Has(types.KeyTrace(denomTraceHash))\n}\n\n// SetDenomTrace sets a new {trace hash -> trace} pair to the store.\nfunc (k Keeper) SetDenomTrace(ctx Context, denomTrace DenomTrace) {\n  store := ctx.KVStore(k.storeKey)\n  bz := k.cdc.MustMarshalBinaryBare(&denomTrace)\n  store.Set(types.KeyTrace(denomTrace.Hash()), bz)\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"MsgTransfer")," will validate that the ",(0,i.kt)("inlineCode",{parentName:"p"},"Coin")," denomination from the ",(0,i.kt)("inlineCode",{parentName:"p"},"Token")," field contains a valid\nhash, if the trace info is provided, or that the base denominations matches:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"func (msg MsgTransfer) ValidateBasic() error {\n  // ...\n  return ValidateIBCDenom(msg.Token.Denom)\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'// ValidateIBCDenom validates that the given denomination is either:\n//\n//  - A valid base denomination (eg: \'uatom\')\n//  - A valid fungible token representation (i.e \'ibc/{hash}\') per ADR 001 https://github.com/cosmos/ibc-go/blob/main/docs/architecture/adr-001-coin-source-tracing.md\nfunc ValidateIBCDenom(denom string) error {\n  denomSplit := strings.SplitN(denom, "/", 2)\n\n  switch {\n  case strings.TrimSpace(denom) == "",\n    len(denomSplit) == 1 && denomSplit[0] == "ibc",\n    len(denomSplit) == 2 && (denomSplit[0] != "ibc" || strings.TrimSpace(denomSplit[1]) == ""):\n    return sdkerrors.Wrapf(ErrInvalidDenomForTransfer, "denomination should be prefixed with the format \'ibc/{hash(trace + \\"/\\" + %s)}\'", denom)\n\n  case denomSplit[0] == denom && strings.TrimSpace(denom) != "":\n    return sdk.ValidateDenom(denom)\n  }\n\n  if _, err := ParseHexHash(denomSplit[1]); err != nil {\n    return Wrapf(err, "invalid denom trace hash %s", denomSplit[1])\n  }\n\n  return nil\n}\n')),(0,i.kt)("p",null,"The denomination trace info only needs to be updated when token is received:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Receiver is ",(0,i.kt)("strong",{parentName:"li"},"source")," chain: The receiver created the token and must have the trace lookup already stored (if necessary ",(0,i.kt)("em",{parentName:"li"},"ie")," native token case wouldn't need a lookup)."),(0,i.kt)("li",{parentName:"ul"},"Receiver is ",(0,i.kt)("strong",{parentName:"li"},"not source")," chain: Store the received info. For example, during step 1, when chain ",(0,i.kt)("inlineCode",{parentName:"li"},"B")," receives ",(0,i.kt)("inlineCode",{parentName:"li"},"transfer/channelToA/denom"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'// SendTransfer\n// ...\n\n  fullDenomPath := token.Denom\n\n// deconstruct the token denomination into the denomination trace info\n// to determine if the sender is the source chain\nif strings.HasPrefix(token.Denom, "ibc/") {\n  fullDenomPath, err = k.DenomPathFromHash(ctx, token.Denom)\n  if err != nil {\n    return err\n  }\n}\n\nif types.SenderChainIsSource(sourcePort, sourceChannel, fullDenomPath) {\n//...\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'// DenomPathFromHash returns the full denomination path prefix from an ibc denom with a hash\n// component.\nfunc (k Keeper) DenomPathFromHash(ctx sdk.Context, denom string) (string, error) {\n  hexHash := denom[4:]\n  hash, err := ParseHexHash(hexHash)\n  if err != nil {\n    return "", Wrap(ErrInvalidDenomForTransfer, err.Error())\n  }\n\n  denomTrace, found := k.GetDenomTrace(ctx, hash)\n  if !found {\n    return "", Wrap(ErrTraceNotFound, hexHash)\n  }\n\n  fullDenomPath := denomTrace.GetFullDenomPath()\n  return fullDenomPath, nil\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'// OnRecvPacket\n// ...\n\n// This is the prefix that would have been prefixed to the denomination\n// on sender chain IF and only if the token originally came from the\n// receiving chain.\n//\n// NOTE: We use SourcePort and SourceChannel here, because the counterparty\n// chain would have prefixed with DestPort and DestChannel when originally\n// receiving this coin as seen in the "sender chain is the source" condition.\nif ReceiverChainIsSource(packet.GetSourcePort(), packet.GetSourceChannel(), data.Denom) {\n  // sender chain is not the source, unescrow tokens\n\n  // remove prefix added by sender chain\n  voucherPrefix := types.GetDenomPrefix(packet.GetSourcePort(), packet.GetSourceChannel())\n  unprefixedDenom := data.Denom[len(voucherPrefix):]\n  token := sdk.NewCoin(unprefixedDenom, sdk.NewIntFromUint64(data.Amount))\n\n  // unescrow tokens\n  escrowAddress := types.GetEscrowAddress(packet.GetDestPort(), packet.GetDestChannel())\n  return k.bankKeeper.SendCoins(ctx, escrowAddress, receiver, sdk.NewCoins(token))\n}\n\n// sender chain is the source, mint vouchers\n\n// since SendPacket did not prefix the denomination, we must prefix denomination here\nsourcePrefix := types.GetDenomPrefix(packet.GetDestPort(), packet.GetDestChannel())\n// NOTE: sourcePrefix contains the trailing "/"\nprefixedDenom := sourcePrefix + data.Denom\n\n// construct the denomination trace from the full raw denomination\ndenomTrace := types.ParseDenomTrace(prefixedDenom)\n\n// set the value to the lookup table if not stored already\ntraceHash := denomTrace.Hash()\nif !k.HasDenomTrace(ctx, traceHash) {\n  k.SetDenomTrace(ctx, traceHash, denomTrace)\n}\n\nvoucherDenom := denomTrace.IBCDenom()\nvoucher := sdk.NewCoin(voucherDenom, sdk.NewIntFromUint64(data.Amount))\n\n// mint new tokens if the source of the transfer is the same chain\nif err := k.bankKeeper.MintCoins(\n  ctx, types.ModuleName, sdk.NewCoins(voucher),\n); err != nil {\n  return err\n}\n\n// send to receiver\nreturn k.bankKeeper.SendCoinsFromModuleToAccount(\n  ctx, types.ModuleName, receiver, sdk.NewCoins(voucher),\n)\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'func NewDenomTraceFromRawDenom(denom string) DenomTrace{\n  denomSplit := strings.Split(denom, "/")\n  trace := ""\n  if len(denomSplit) > 1 {\n    trace = strings.Join(denomSplit[:len(denomSplit)-1], "/")\n  }\n  return DenomTrace{\n    BaseDenom: denomSplit[len(denomSplit)-1],\n    Trace:     trace,\n  }\n}\n')),(0,i.kt)("p",null,"One final remark is that the ",(0,i.kt)("inlineCode",{parentName:"p"},"FungibleTokenPacketData")," will remain the same, i.e with the prefixed full denomination, since the receiving chain may not be an SDK-based chain."),(0,i.kt)("h3",{id:"coin-changes"},"Coin Changes"),(0,i.kt)("p",null,"The coin denomination validation will need to be updated to reflect these changes. In particular, the denomination validation\nfunction will now:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Accept slash separators (",(0,i.kt)("inlineCode",{parentName:"li"},'"/"'),") and uppercase characters (due to the ",(0,i.kt)("inlineCode",{parentName:"li"},"HexBytes")," format)"),(0,i.kt)("li",{parentName:"ul"},"Bump the maximum character length to 128, as the hex representation used by Tendermint's\n",(0,i.kt)("inlineCode",{parentName:"li"},"HexBytes")," type contains 64 characters.")),(0,i.kt)("p",null,"Additional validation logic, such as verifying the length of the hash, the  may be added to the bank module in the future if the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/pull/6755"},"custom base denomination validation")," is integrated into the SDK."),(0,i.kt)("h3",{id:"positive"},"Positive"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Clearer separation of the source tracing behaviour of the token (transfer prefix) from the original\n",(0,i.kt)("inlineCode",{parentName:"li"},"Coin")," denomination"),(0,i.kt)("li",{parentName:"ul"},"Consistent validation of ",(0,i.kt)("inlineCode",{parentName:"li"},"Coin")," fields (i.e no special characters, fixed max length)"),(0,i.kt)("li",{parentName:"ul"},"Cleaner ",(0,i.kt)("inlineCode",{parentName:"li"},"Coin")," and standard denominations for IBC"),(0,i.kt)("li",{parentName:"ul"},"No additional fields to SDK ",(0,i.kt)("inlineCode",{parentName:"li"},"Coin"))),(0,i.kt)("h3",{id:"negative"},"Negative"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Store each set of tracing denomination identifiers on the ",(0,i.kt)("inlineCode",{parentName:"li"},"ibc-transfer")," module store"),(0,i.kt)("li",{parentName:"ul"},"Clients will have to fetch the base denomination every time they receive a new relayed fungible token over IBC. This can be mitigated using a map/cache for already seen hashes on the client side. Other forms of mitigation, would be opening a websocket connection subscribe to incoming events.")),(0,i.kt)("h3",{id:"neutral"},"Neutral"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Slight difference with the ICS20 spec"),(0,i.kt)("li",{parentName:"ul"},"Additional validation logic for IBC coins on the ",(0,i.kt)("inlineCode",{parentName:"li"},"ibc-transfer")," module"),(0,i.kt)("li",{parentName:"ul"},"Additional genesis fields"),(0,i.kt)("li",{parentName:"ul"},"Slightly increases the gas usage on cross-chain transfers due to access to the store. This should\nbe inter-block cached if transfers are frequent.")),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/cosmos/ibc/tree/master/spec/app/ics-020-fungible-token-transfer"},"ICS 20 - Fungible token transfer")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/cosmos/cosmos-sdk/pull/6755"},"Custom Coin Denomination validation"))))}m.isMDXComponent=!0}}]);
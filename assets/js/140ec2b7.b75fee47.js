"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3401],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>k});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},c=Object.keys(e);for(a=0;a<c.length;a++)n=c[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(a=0;a<c.length;a++)n=c[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},l=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,c=e.originalType,s=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),d=p(n),u=o,k=d["".concat(s,".").concat(u)]||d[u]||m[u]||c;return n?a.createElement(k,r(r({ref:t},l),{},{components:n})):a.createElement(k,r({ref:t},l))}));function k(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var c=n.length,r=new Array(c);r[0]=u;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[d]="string"==typeof e?e:o,r[1]=i;for(var p=2;p<c;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},96561:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>c,metadata:()=>i,toc:()=>p});var a=n(87462),o=(n(67294),n(3905));const c={title:"Define packets and acks",sidebar_label:"Define packets and acks",sidebar_position:5,slug:"/ibc/apps/packets_acks"},r="Define packets and acks",i={unversionedId:"ibc/apps/packets_acks",id:"version-v6.2.x/ibc/apps/packets_acks",title:"Define packets and acks",description:"Learn how to define custom packet and acknowledgement structs and how to encode and decode them.",source:"@site/versioned_docs/version-v6.2.x/01-ibc/03-apps/05-packets_acks.md",sourceDirName:"01-ibc/03-apps",slug:"/ibc/apps/packets_acks",permalink:"/v6/ibc/apps/packets_acks",draft:!1,tags:[],version:"v6.2.x",sidebarPosition:5,frontMatter:{title:"Define packets and acks",sidebar_label:"Define packets and acks",sidebar_position:5,slug:"/ibc/apps/packets_acks"},sidebar:"defaultSidebar",previous:{title:"Keeper",permalink:"/v6/ibc/apps/keeper"},next:{title:"Routing",permalink:"/v6/ibc/apps/routing"}},s={},p=[{value:"Custom packets",id:"custom-packets",level:2},{value:"Acknowledgements",id:"acknowledgements",level:2}],l={toc:p},d="wrapper";function m(e){let{components:t,...n}=e;return(0,o.kt)(d,(0,a.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"define-packets-and-acks"},"Define packets and acks"),(0,o.kt)("admonition",{title:"Synopsis",type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Learn how to define custom packet and acknowledgement structs and how to encode and decode them.")),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("h2",{parentName:"admonition",id:"pre-requisite-readings"},"Pre-requisite readings"),(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/v6/ibc/overview"},"IBC Overview")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/v6/ibc/integration"},"IBC default integration")))),(0,o.kt)("h2",{id:"custom-packets"},"Custom packets"),(0,o.kt)("p",null,"Modules connected by a channel must agree on what application data they are sending over the\nchannel, as well as how they will encode/decode it. This process is not specified by IBC as it is up\nto each application module to determine how to implement this agreement. However, for most\napplications this will happen as a version negotiation during the channel handshake. While more\ncomplex version negotiation is possible to implement inside the channel opening handshake, a very\nsimple version negotiation is implemented in the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc-go/tree/main/modules/apps/transfer/module.go"},"ibc-transfer module"),"."),(0,o.kt)("p",null,"Thus, a module must define its custom packet data structure, along with a well-defined way to\nencode and decode it to and from ",(0,o.kt)("inlineCode",{parentName:"p"},"[]byte"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"// Custom packet data defined in application module\ntype CustomPacketData struct {\n    // Custom fields ...\n}\n\nEncodePacketData(packetData CustomPacketData) []byte {\n    // encode packetData to bytes\n}\n\nDecodePacketData(encoded []byte) (CustomPacketData) {\n    // decode from bytes to packet data\n}\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note that the ",(0,o.kt)("inlineCode",{parentName:"p"},"CustomPacketData")," struct is defined in the proto definition and then compiled by the protobuf compiler.")),(0,o.kt)("p",null,"Then a module must encode its packet data before sending it through IBC."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"// retrieve the dynamic capability for this channel\nchannelCap := scopedKeeper.GetCapability(ctx, channelCapName)\n// Sending custom application packet data\ndata := EncodePacketData(customPacketData)\n// Send packet to IBC, authenticating with channelCap\nsequence, err := IBCChannelKeeper.SendPacket(\n    ctx,\n    channelCap,\n    sourcePort,\n    sourceChannel,\n    timeoutHeight,\n    timeoutTimestamp,\n    data,\n)\n")),(0,o.kt)("p",null,"A module receiving a packet must decode the ",(0,o.kt)("inlineCode",{parentName:"p"},"PacketData")," into a structure it expects so that it can\nact on it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"// Receiving custom application packet data (in OnRecvPacket)\npacketData := DecodePacketData(packet.Data)\n// handle received custom packet data\n")),(0,o.kt)("h2",{id:"acknowledgements"},"Acknowledgements"),(0,o.kt)("p",null,"Modules may commit an acknowledgement upon receiving and processing a packet in the case of synchronous packet processing.\nIn the case where a packet is processed at some later point after the packet has been received (asynchronous execution), the acknowledgement\nwill be written once the packet has been processed by the application which may be well after the packet receipt."),(0,o.kt)("p",null,"NOTE: Most blockchain modules will want to use the synchronous execution model in which the module processes and writes the acknowledgement\nfor a packet as soon as it has been received from the IBC module."),(0,o.kt)("p",null,"This acknowledgement can then be relayed back to the original sender chain, which can take action\ndepending on the contents of the acknowledgement."),(0,o.kt)("p",null,"Just as packet data was opaque to IBC, acknowledgements are similarly opaque. Modules must pass and\nreceive acknowledegments with the IBC modules as byte strings."),(0,o.kt)("p",null,"Thus, modules must agree on how to encode/decode acknowledgements. The process of creating an\nacknowledgement struct along with encoding and decoding it, is very similar to the packet data\nexample above. ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc/blob/master/spec/core/ics-004-channel-and-packet-semantics#acknowledgement-envelope"},"ICS 04"),"\nspecifies a recommended format for acknowledgements. This acknowledgement type can be imported from\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc-go/tree/main/modules/core/04-channel/types"},"channel types"),"."),(0,o.kt)("p",null,"While modules may choose arbitrary acknowledgement structs, a default acknowledgement types is provided by IBC ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc-go/blob/main/proto/ibc/core/channel/v1/channel.proto"},"here"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-protobuf"},"// Acknowledgement is the recommended acknowledgement format to be used by\n// app-specific protocols.\n// NOTE: The field numbers 21 and 22 were explicitly chosen to avoid accidental\n// conflicts with other protobuf message formats used for acknowledgements.\n// The first byte of any message with this format will be the non-ASCII values\n// `0xaa` (result) or `0xb2` (error). Implemented as defined by ICS:\n// https://github.com/cosmos/ibc/tree/master/spec/core/ics-004-channel-and-packet-semantics#acknowledgement-envelope\nmessage Acknowledgement {\n  // response contains either a result or an error and must be non-empty\n  oneof response {\n    bytes  result = 21;\n    string error  = 22;\n  }\n}\n")))}m.isMDXComponent=!0}}]);
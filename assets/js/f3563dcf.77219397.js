"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3845],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var a=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(t),u=o,m=d["".concat(s,".").concat(u)]||d[u]||h[u]||i;return t?a.createElement(m,r(r({ref:n},p),{},{components:t})):a.createElement(m,r({ref:n},p))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,r=new Array(i);r[0]=u;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[d]="string"==typeof e?e:o,r[1]=l;for(var c=2;c<i;c++)r[c]=t[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},13430:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var a=t(87462),o=(t(67294),t(3905));const i={title:"IBC Applications",sidebar_label:"IBC Applications",sidebar_position:1,slug:"/ibc/apps/apps"},r="IBC Applications",l={unversionedId:"ibc/apps/apps",id:"ibc/apps/apps",title:"IBC Applications",description:"Learn how to configure your application to use IBC and send data packets to other chains.",source:"@site/docs/01-ibc/03-apps/01-apps.md",sourceDirName:"01-ibc/03-apps",slug:"/ibc/apps/apps",permalink:"/main/ibc/apps/apps",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"IBC Applications",sidebar_label:"IBC Applications",sidebar_position:1,slug:"/ibc/apps/apps"},sidebar:"defaultSidebar",previous:{title:"Integration",permalink:"/main/ibc/integration"},next:{title:"Implement IBCModule interface and callbacks",permalink:"/main/ibc/apps/ibcmodule"}},s={},c=[{value:"Create a custom IBC application module",id:"create-a-custom-ibc-application-module",level:2},{value:"Implement <code>IBCModule</code> Interface and callbacks",id:"implement-ibcmodule-interface-and-callbacks",level:3},{value:"Channel Handshake Version Negotiation",id:"channel-handshake-version-negotiation",level:4},{value:"Bind Ports",id:"bind-ports",level:3},{value:"Custom Packets",id:"custom-packets",level:3},{value:"Packet Flow Handling",id:"packet-flow-handling",level:4},{value:"Sending Packets",id:"sending-packets",level:5},{value:"Receiving Packets",id:"receiving-packets",level:5},{value:"Acknowledgements",id:"acknowledgements",level:3},{value:"Acknowledging Packets",id:"acknowledging-packets",level:4},{value:"Timeout Packets",id:"timeout-packets",level:4},{value:"Routing",id:"routing",level:3},{value:"Working Example",id:"working-example",level:2}],p={toc:c},d="wrapper";function h(e){let{components:n,...t}=e;return(0,o.kt)(d,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"ibc-applications"},"IBC Applications"),(0,o.kt)("p",null,"Learn how to configure your application to use IBC and send data packets to other chains. {synopsis}"),(0,o.kt)("p",null,"This document serves as a guide for developers who want to write their own Inter-blockchain\nCommunication Protocol (IBC) applications for custom use cases."),(0,o.kt)("p",null,"Due to the modular design of the IBC protocol, IBC\napplication developers do not need to concern themselves with the low-level details of clients,\nconnections, and proof verification. Nevertheless a brief explanation of the lower levels of the\nstack is given so that application developers may have a high-level understanding of the IBC\nprotocol. Then the document goes into detail on the abstraction layer most relevant for application\ndevelopers (channels and ports), and describes how to define your own custom packets, and\n",(0,o.kt)("inlineCode",{parentName:"p"},"IBCModule")," callbacks."),(0,o.kt)("p",null,"To have your module interact over IBC you must: bind to a port(s), define your own packet data and acknowledgement structs as well as how to encode/decode them, and implement the\n",(0,o.kt)("inlineCode",{parentName:"p"},"IBCModule")," interface. Below is a more detailed explanation of how to write an IBC application\nmodule correctly."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("h2",{parentName:"admonition",id:"pre-requisites-readings"},"Pre-requisites Readings"),(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/main/ibc/overview"},"IBC Overview")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/main/ibc/integration"},"IBC default integration")))),(0,o.kt)("h2",{id:"create-a-custom-ibc-application-module"},"Create a custom IBC application module"),(0,o.kt)("h3",{id:"implement-ibcmodule-interface-and-callbacks"},"Implement ",(0,o.kt)("inlineCode",{parentName:"h3"},"IBCModule")," Interface and callbacks"),(0,o.kt)("p",null,"The Cosmos SDK expects all IBC modules to implement the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc-go/tree/main/modules/core/05-port/types/module.go"},(0,o.kt)("inlineCode",{parentName:"a"},"IBCModule"),"\ninterface"),". This\ninterface contains all of the callbacks IBC expects modules to implement. This section will describe\nthe callbacks that are called during channel handshake execution."),(0,o.kt)("p",null,"Here are the channel handshake callbacks that modules are expected to implement:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"// Called by IBC Handler on MsgOpenInit\nfunc (k Keeper) OnChanOpenInit(ctx sdk.Context,\n  order channeltypes.Order,\n  connectionHops []string,\n  portID string,\n  channelID string,\n  channelCap *capabilitytypes.Capability,\n  counterparty channeltypes.Counterparty,\n  version string,\n) error {\n  // OpenInit must claim the channelCapability that IBC passes into the callback\n  if err := k.ClaimCapability(ctx, chanCap, host.ChannelCapabilityPath(portID, channelID)); err != nil {\n    return err\n }\n\n  // ... do custom initialization logic\n\n  // Use above arguments to determine if we want to abort handshake\n  // Examples: Abort if order == UNORDERED,\n  // Abort if version is unsupported\n  err := checkArguments(args)\n  return err\n}\n\n// Called by IBC Handler on MsgOpenTry\nOnChanOpenTry(\n  ctx sdk.Context,\n  order channeltypes.Order,\n  connectionHops []string,\n  portID,\n  channelID string,\n  channelCap *capabilitytypes.Capability,\n  counterparty channeltypes.Counterparty,\n  counterpartyVersion string,\n) (string, error) {\n  // OpenTry must claim the channelCapability that IBC passes into the callback\n  if err := k.scopedKeeper.ClaimCapability(ctx, chanCap, host.ChannelCapabilityPath(portID, channelID)); err != nil {\n    return err\n  }\n  \n  // ... do custom initialization logic\n\n  // Use above arguments to determine if we want to abort handshake\n  if err := checkArguments(args); err != nil {\n    return err\n  }\n\n  // Construct application version \n  // IBC applications must return the appropriate application version\n  // This can be a simple string or it can be a complex version constructed\n  // from the counterpartyVersion and other arguments. \n  // The version returned will be the channel version used for both channel ends. \n  appVersion := negotiateAppVersion(counterpartyVersion, args)\n  \n  return appVersion, nil\n}\n\n// Called by IBC Handler on MsgOpenAck\nOnChanOpenAck(\n  ctx sdk.Context,\n  portID,\n  channelID string,\n  counterpartyVersion string,\n) error {\n  // ... do custom initialization logic\n\n  // Use above arguments to determine if we want to abort handshake\n  err := checkArguments(args)\n  return err\n}\n\n// Called by IBC Handler on MsgOpenConfirm\nOnChanOpenConfirm(\n  ctx sdk.Context,\n  portID,\n  channelID string,\n) error {\n  // ... do custom initialization logic\n\n  // Use above arguments to determine if we want to abort handshake\n  err := checkArguments(args)\n  return err\n}\n")),(0,o.kt)("p",null,"The channel closing handshake will also invoke module callbacks that can return errors to abort the\nclosing handshake. Closing a channel is a 2-step handshake, the initiating chain calls\n",(0,o.kt)("inlineCode",{parentName:"p"},"ChanCloseInit")," and the finalizing chain calls ",(0,o.kt)("inlineCode",{parentName:"p"},"ChanCloseConfirm"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"// Called by IBC Handler on MsgCloseInit\nOnChanCloseInit(\n  ctx sdk.Context,\n  portID,\n  channelID string,\n) error {\n  // ... do custom finalization logic\n\n  // Use above arguments to determine if we want to abort handshake\n  err := checkArguments(args)\n  return err\n}\n\n// Called by IBC Handler on MsgCloseConfirm\nOnChanCloseConfirm(\n  ctx sdk.Context,\n  portID,\n  channelID string,\n) error {\n  // ... do custom finalization logic\n\n  // Use above arguments to determine if we want to abort handshake\n  err := checkArguments(args)\n  return err\n}\n")),(0,o.kt)("h4",{id:"channel-handshake-version-negotiation"},"Channel Handshake Version Negotiation"),(0,o.kt)("p",null,"Application modules are expected to verify versioning used during the channel handshake procedure."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ChanOpenInit")," callback should verify that the ",(0,o.kt)("inlineCode",{parentName:"li"},"MsgChanOpenInit.Version")," is valid"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ChanOpenTry")," callback should construct the application version used for both channel ends. If no application version can be constructed, it must return an error."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ChanOpenAck")," callback should verify that the ",(0,o.kt)("inlineCode",{parentName:"li"},"MsgChanOpenAck.CounterpartyVersion")," is valid and supported.")),(0,o.kt)("p",null,"IBC expects application modules to perform application version negotiation in ",(0,o.kt)("inlineCode",{parentName:"p"},"OnChanOpenTry"),". The negotiated version\nmust be returned to core IBC. If the version cannot be negotiated, an error should be returned."),(0,o.kt)("p",null,"Versions must be strings but can implement any versioning structure. If your application plans to\nhave linear releases then semantic versioning is recommended. If your application plans to release\nvarious features in between major releases then it is advised to use the same versioning scheme\nas IBC. This versioning scheme specifies a version identifier and compatible feature set with\nthat identifier. Valid version selection includes selecting a compatible version identifier with\na subset of features supported by your application for that version. The struct is used for this\nscheme can be found in ",(0,o.kt)("inlineCode",{parentName:"p"},"03-connection/types"),"."),(0,o.kt)("p",null,"Since the version type is a string, applications have the ability to do simple version verification\nvia string matching or they can use the already implemented versioning system and pass the proto\nencoded version into each handhshake call as necessary."),(0,o.kt)("p",null,"ICS20 currently implements basic string matching with a single supported version."),(0,o.kt)("h3",{id:"bind-ports"},"Bind Ports"),(0,o.kt)("p",null,"Currently, ports must be bound on app initialization. A module may bind to ports in ",(0,o.kt)("inlineCode",{parentName:"p"},"InitGenesis"),"\nlike so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"func InitGenesis(ctx sdk.Context, keeper keeper.Keeper, state types.GenesisState) {\n  // ... other initialization logic\n\n  // Only try to bind to port if it is not already bound, since we may already own\n  // port capability from capability InitGenesis\n  if !hasCapability(ctx, state.PortID) {\n    // module binds to desired ports on InitChain\n    // and claims returned capabilities\n    cap1 := keeper.IBCPortKeeper.BindPort(ctx, port1)\n    cap2 := keeper.IBCPortKeeper.BindPort(ctx, port2)\n    cap3 := keeper.IBCPortKeeper.BindPort(ctx, port3)\n\n    // NOTE: The module's scoped capability keeper must be private\n    keeper.scopedKeeper.ClaimCapability(cap1)\n    keeper.scopedKeeper.ClaimCapability(cap2)\n    keeper.scopedKeeper.ClaimCapability(cap3)\n  }\n\n  // ... more initialization logic\n}\n")),(0,o.kt)("h3",{id:"custom-packets"},"Custom Packets"),(0,o.kt)("p",null,"Modules connected by a channel must agree on what application data they are sending over the\nchannel, as well as how they will encode/decode it. This process is not specified by IBC as it is up\nto each application module to determine how to implement this agreement. However, for most\napplications this will happen as a version negotiation during the channel handshake. While more\ncomplex version negotiation is possible to implement inside the channel opening handshake, a very\nsimple version negotiation is implemented in the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc-go/tree/main/modules/apps/transfer/module.go"},"ibc-transfer module"),"."),(0,o.kt)("p",null,"Thus, a module must define its custom packet data structure, along with a well-defined way to\nencode and decode it to and from ",(0,o.kt)("inlineCode",{parentName:"p"},"[]byte"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"// Custom packet data defined in application module\ntype CustomPacketData struct {\n  // Custom fields ...\n}\n\nEncodePacketData(packetData CustomPacketData) []byte {\n  // encode packetData to bytes\n}\n\nDecodePacketData(encoded []byte) (CustomPacketData) {\n  // decode from bytes to packet data\n}\n")),(0,o.kt)("p",null,"Then a module must encode its packet data before sending it through IBC."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"// retrieve the dynamic capability for this channel\nchannelCap := scopedKeeper.GetCapability(ctx, channelCapName)\n// Sending custom application packet data\ndata := EncodePacketData(customPacketData)\npacket.Data = data\n// Send packet to IBC, authenticating with channelCap\nsequence, err := IBCChannelKeeper.SendPacket(\n  ctx, \n  channelCap, \n  sourcePort, \n  sourceChannel, \n  timeoutHeight, \n  timeoutTimestamp, \n  data,\n)\n")),(0,o.kt)("p",null,"A module receiving a packet must decode the ",(0,o.kt)("inlineCode",{parentName:"p"},"PacketData")," into a structure it expects so that it can\nact on it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"// Receiving custom application packet data (in OnRecvPacket)\npacketData := DecodePacketData(packet.Data)\n// handle received custom packet data\n")),(0,o.kt)("h4",{id:"packet-flow-handling"},"Packet Flow Handling"),(0,o.kt)("p",null,"Just as IBC expected modules to implement callbacks for channel handshakes, IBC also expects modules\nto implement callbacks for handling the packet flow through a channel."),(0,o.kt)("p",null,"Once a module A and module B are connected to each other, relayers can start relaying packets and\nacknowledgements back and forth on the channel."),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://media.githubusercontent.com/media/cosmos/ibc/old/spec/ics-004-channel-and-packet-semantics/channel-state-machine.png",alt:"IBC packet flow diagram"})),(0,o.kt)("p",null,"Briefly, a successful packet flow works as follows:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"module A sends a packet through the IBC module"),(0,o.kt)("li",{parentName:"ol"},"the packet is received by module B"),(0,o.kt)("li",{parentName:"ol"},"if module B writes an acknowledgement of the packet then module A will process the\nacknowledgement"),(0,o.kt)("li",{parentName:"ol"},"if the packet is not successfully received before the timeout, then module A processes the\npacket's timeout.")),(0,o.kt)("h5",{id:"sending-packets"},"Sending Packets"),(0,o.kt)("p",null,"Modules do not send packets through callbacks, since the modules initiate the action of sending\npackets to the IBC module, as opposed to other parts of the packet flow where msgs sent to the IBC\nmodule must trigger execution on the port-bound module through the use of callbacks. Thus, to send a\npacket a module simply needs to call ",(0,o.kt)("inlineCode",{parentName:"p"},"SendPacket")," on the ",(0,o.kt)("inlineCode",{parentName:"p"},"IBCChannelKeeper"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"// retrieve the dynamic capability for this channel\nchannelCap := scopedKeeper.GetCapability(ctx, channelCapName)\n// Sending custom application packet data\ndata := EncodePacketData(customPacketData)\n// Send packet to IBC, authenticating with channelCap\nsequence, err := IBCChannelKeeper.SendPacket(\n  ctx, \n  channelCap, \n  sourcePort, \n  sourceChannel, \n  timeoutHeight, \n  timeoutTimestamp, \n  data,\n)\n")),(0,o.kt)("p",null,"::: warning\nIn order to prevent modules from sending packets on channels they do not own, IBC expects\nmodules to pass in the correct channel capability for the packet's source channel.\n:::"),(0,o.kt)("h5",{id:"receiving-packets"},"Receiving Packets"),(0,o.kt)("p",null,"To handle receiving packets, the module must implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"OnRecvPacket")," callback. This gets\ninvoked by the IBC module after the packet has been proved valid and correctly processed by the IBC\nkeepers. Thus, the ",(0,o.kt)("inlineCode",{parentName:"p"},"OnRecvPacket")," callback only needs to worry about making the appropriate state\nchanges given the packet data without worrying about whether the packet is valid or not."),(0,o.kt)("p",null,"Modules may return to the IBC handler an acknowledgement which implements the Acknowledgement interface.\nThe IBC handler will then commit this acknowledgement of the packet so that a relayer may relay the\nacknowledgement back to the sender module."),(0,o.kt)("p",null,"The state changes that occurred during this callback will only be written if:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"the acknowledgement was successful as indicated by the ",(0,o.kt)("inlineCode",{parentName:"li"},"Success()")," function of the acknowledgement"),(0,o.kt)("li",{parentName:"ul"},"if the acknowledgement returned is nil indicating that an asynchronous process is occurring")),(0,o.kt)("p",null,"NOTE: Applications which process asynchronous acknowledgements must handle reverting state changes\nwhen appropriate. Any state changes that occurred during the ",(0,o.kt)("inlineCode",{parentName:"p"},"OnRecvPacket")," callback will be written\nfor asynchronous acknowledgements."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"OnRecvPacket(\n  ctx sdk.Context,\n  packet channeltypes.Packet,\n) ibcexported.Acknowledgement {\n  // Decode the packet data\n  packetData := DecodePacketData(packet.Data)\n\n  // do application state changes based on packet data and return the acknowledgement\n  // NOTE: The acknowledgement will indicate to the IBC handler if the application \n  // state changes should be written via the `Success()` function. Application state\n  // changes are only written if the acknowledgement is successful or the acknowledgement\n  // returned is nil indicating that an asynchronous acknowledgement will occur.\n  ack := processPacket(ctx, packet, packetData)\n\n  return ack\n}\n")),(0,o.kt)("p",null,"The Acknowledgement interface:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"// Acknowledgement defines the interface used to return\n// acknowledgements in the OnRecvPacket callback.\ntype Acknowledgement interface {\n  Success() bool\n  Acknowledgement() []byte\n}\n")),(0,o.kt)("h3",{id:"acknowledgements"},"Acknowledgements"),(0,o.kt)("p",null,"Modules may commit an acknowledgement upon receiving and processing a packet in the case of synchronous packet processing.\nIn the case where a packet is processed at some later point after the packet has been received (asynchronous execution), the acknowledgement\nwill be written once the packet has been processed by the application which may be well after the packet receipt."),(0,o.kt)("p",null,"NOTE: Most blockchain modules will want to use the synchronous execution model in which the module processes and writes the acknowledgement\nfor a packet as soon as it has been received from the IBC module."),(0,o.kt)("p",null,"This acknowledgement can then be relayed back to the original sender chain, which can take action\ndepending on the contents of the acknowledgement."),(0,o.kt)("p",null,"Just as packet data was opaque to IBC, acknowledgements are similarly opaque. Modules must pass and\nreceive acknowledegments with the IBC modules as byte strings."),(0,o.kt)("p",null,"Thus, modules must agree on how to encode/decode acknowledgements. The process of creating an\nacknowledgement struct along with encoding and decoding it, is very similar to the packet data\nexample above. ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc/blob/master/spec/core/ics-004-channel-and-packet-semantics#acknowledgement-envelope"},"ICS 04"),"\nspecifies a recommended format for acknowledgements. This acknowledgement type can be imported from\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc-go/tree/main/modules/core/04-channel/types"},"channel types"),"."),(0,o.kt)("p",null,"While modules may choose arbitrary acknowledgement structs, a default acknowledgement types is provided by IBC ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc-go/blob/main/proto/ibc/core/channel/v1/channel.proto"},"here"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-proto"},"// Acknowledgement is the recommended acknowledgement format to be used by\n// app-specific protocols.\n// NOTE: The field numbers 21 and 22 were explicitly chosen to avoid accidental\n// conflicts with other protobuf message formats used for acknowledgements.\n// The first byte of any message with this format will be the non-ASCII values\n// `0xaa` (result) or `0xb2` (error). Implemented as defined by ICS:\n// https://github.com/cosmos/ibc/tree/master/spec/core/ics-004-channel-and-packet-semantics#acknowledgement-envelope\nmessage Acknowledgement {\n  // response contains either a result or an error and must be non-empty\n  oneof response {\n    bytes  result = 21;\n    string error  = 22;\n  }\n}\n")),(0,o.kt)("h4",{id:"acknowledging-packets"},"Acknowledging Packets"),(0,o.kt)("p",null,"After a module writes an acknowledgement, a relayer can relay back the acknowledgement to the sender module. The sender module can\nthen process the acknowledgement using the ",(0,o.kt)("inlineCode",{parentName:"p"},"OnAcknowledgementPacket")," callback. The contents of the\nacknowledgement is entirely upto the modules on the channel (just like the packet data); however, it\nmay often contain information on whether the packet was successfully processed along\nwith some additional data that could be useful for remediation if the packet processing failed."),(0,o.kt)("p",null,"Since the modules are responsible for agreeing on an encoding/decoding standard for packet data and\nacknowledgements, IBC will pass in the acknowledgements as ",(0,o.kt)("inlineCode",{parentName:"p"},"[]byte")," to this callback. The callback\nis responsible for decoding the acknowledgement and processing it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"OnAcknowledgementPacket(\n  ctx sdk.Context,\n  packet channeltypes.Packet,\n  acknowledgement []byte,\n) (*sdk.Result, error) {\n  // Decode acknowledgement\n  ack := DecodeAcknowledgement(acknowledgement)\n\n  // process ack\n  res, err := processAck(ack)\n  return res, err\n}\n")),(0,o.kt)("h4",{id:"timeout-packets"},"Timeout Packets"),(0,o.kt)("p",null,"If the timeout for a packet is reached before the packet is successfully received or the\ncounterparty channel end is closed before the packet is successfully received, then the receiving\nchain can no longer process it. Thus, the sending chain must process the timeout using\n",(0,o.kt)("inlineCode",{parentName:"p"},"OnTimeoutPacket")," to handle this situation. Again the IBC module will verify that the timeout is\nindeed valid, so our module only needs to implement the state machine logic for what to do once a\ntimeout is reached and the packet can no longer be received."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"OnTimeoutPacket(\n  ctx sdk.Context,\n  packet channeltypes.Packet,\n) (*sdk.Result, error) {\n  // do custom timeout logic\n}\n")),(0,o.kt)("h3",{id:"routing"},"Routing"),(0,o.kt)("p",null,"As mentioned above, modules must implement the IBC module interface (which contains both channel\nhandshake callbacks and packet handling callbacks). The concrete implementation of this interface\nmust be registered with the module name as a route on the IBC ",(0,o.kt)("inlineCode",{parentName:"p"},"Router"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"// app.go\nfunc NewApp(...args) *App {\n// ...\n\n// Create static IBC router, add module routes, then set and seal it\nibcRouter := port.NewRouter()\n\nibcRouter.AddRoute(ibctransfertypes.ModuleName, transferModule)\n// Note: moduleCallbacks must implement IBCModule interface\nibcRouter.AddRoute(moduleName, moduleCallbacks)\n\n// Setting Router will finalize all routes by sealing router\n// No more routes can be added\napp.IBCKeeper.SetRouter(ibcRouter)\n")),(0,o.kt)("h2",{id:"working-example"},"Working Example"),(0,o.kt)("p",null,"For a real working example of an IBC application, you can look through the ",(0,o.kt)("inlineCode",{parentName:"p"},"ibc-transfer")," module\nwhich implements everything discussed above."),(0,o.kt)("p",null,"Here are the useful parts of the module to look at:"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc-go/blob/main/modules/apps/transfer/keeper/genesis.go"},"Binding to transfer\nport")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc-go/blob/main/modules/apps/transfer/keeper/relay.go"},"Sending transfer\npackets")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc-go/blob/main/modules/apps/transfer/ibc_module.go"},"Implementing IBC\ncallbacks")))}h.isMDXComponent=!0}}]);
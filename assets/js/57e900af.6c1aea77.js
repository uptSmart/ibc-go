"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7648],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=a.createContext({}),s=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=s(e.components);return a.createElement(c.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=s(t),h=r,m=d["".concat(c,".").concat(h)]||d[h]||u[h]||i;return t?a.createElement(m,o(o({ref:n},p),{},{components:t})):a.createElement(m,o({ref:n},p))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=h;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l[d]="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=t[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},83121:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var a=t(87462),r=(t(67294),t(3905));const i={},o="ADR 015: IBC Packet Receiver",l={unversionedId:"adr-015-ibc-packet-receiver",id:"adr-015-ibc-packet-receiver",title:"ADR 015: IBC Packet Receiver",description:"Changelog",source:"@site/architecture/adr-015-ibc-packet-receiver.md",sourceDirName:".",slug:"/adr-015-ibc-packet-receiver",permalink:"/architecture/adr-015-ibc-packet-receiver",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"ADR 011: ICS-20 transfer state entry for total amount of tokens in escrow",permalink:"/architecture/adr-011-transfer-total-escrow-state-entry"},next:{title:"ADR 025: IBC Passive Channels",permalink:"/architecture/adr-025-ibc-passive-channels"}},c={},s=[{value:"Changelog",id:"changelog",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Status",id:"status",level:2},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"References",id:"references",level:2}],p={toc:s},d="wrapper";function u(e){let{components:n,...t}=e;return(0,r.kt)(d,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"adr-015-ibc-packet-receiver"},"ADR 015: IBC Packet Receiver"),(0,r.kt)("h2",{id:"changelog"},"Changelog"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"2019 Oct 22: Initial Draft")),(0,r.kt)("h2",{id:"context"},"Context"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc/tree/master/spec/core/ics-026-routing-module"},"ICS 26 - Routing Module")," defines a function ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc/tree/master/spec/core/ics-026-routing-module#packet-relay"},(0,r.kt)("inlineCode",{parentName:"a"},"handlePacketRecv")),"."),(0,r.kt)("p",null,"In ICS 26, the routing module is defined as a layer above each application module\nwhich verifies and routes messages to the destination modules. It is possible to\nimplement it as a separate module, however, we already have functionality to route\nmessages upon the destination identifiers in the baseapp. This ADR suggests\nto utilize existing ",(0,r.kt)("inlineCode",{parentName:"p"},"baseapp.router")," to route packets to application modules."),(0,r.kt)("p",null,"Generally, routing module callbacks have two separate steps in them,\nverification and execution. This corresponds to the ",(0,r.kt)("inlineCode",{parentName:"p"},"AnteHandler"),"-",(0,r.kt)("inlineCode",{parentName:"p"},"Handler"),"\nmodel inside the SDK. We can do the verification inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"AnteHandler"),"\nin order to increase developer ergonomics by reducing boilerplate\nverification code."),(0,r.kt)("p",null,"For atomic multi-message transaction, we want to keep the IBC related\nstate modification to be preserved even the application side state change\nreverts. One of the example might be IBC token sending message following with\nstake delegation which uses the tokens received by the previous packet message.\nIf the token receiving fails for any reason, we might not want to keep\nexecuting the transaction, but we also don't want to abort the transaction\nor the sequence and commitment will be reverted and the channel will be stuck.\nThis ADR suggests new ",(0,r.kt)("inlineCode",{parentName:"p"},"CodeType"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"CodeTxBreak"),", to fix this problem."),(0,r.kt)("h2",{id:"decision"},"Decision"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"PortKeeper")," will have the capability key that is able to access only the\nchannels bound to the port. Entities that hold a ",(0,r.kt)("inlineCode",{parentName:"p"},"PortKeeper")," will be\nable to call the methods on it which are corresponding with the methods with\nthe same names on the ",(0,r.kt)("inlineCode",{parentName:"p"},"ChannelKeeper"),", but only with the\nallowed port. ",(0,r.kt)("inlineCode",{parentName:"p"},"ChannelKeeper.Port(string, ChannelChecker)")," will be defined to\neasily construct a capability-safe ",(0,r.kt)("inlineCode",{parentName:"p"},"PortKeeper"),". This will be addressed in\nanother ADR and we will use insecure ",(0,r.kt)("inlineCode",{parentName:"p"},"ChannelKeeper")," for now."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"baseapp.runMsgs")," will break the loop over the messages if one of the handlers\nreturns ",(0,r.kt)("inlineCode",{parentName:"p"},"!Result.IsOK()"),". However, the outer logic will write the cached\nstore if ",(0,r.kt)("inlineCode",{parentName:"p"},"Result.IsOK() || Result.Code.IsBreak()"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"Result.Code.IsBreak()")," if\n",(0,r.kt)("inlineCode",{parentName:"p"},"Result.Code == CodeTxBreak"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func (app *BaseApp) runTx(tx Tx) (result Result) {\n  msgs := tx.GetMsgs()\n  \n  // AnteHandler\n  if app.anteHandler != nil {\n    anteCtx, msCache := app.cacheTxContext(ctx)\n    newCtx, err := app.anteHandler(anteCtx, tx)\n    if !newCtx.IsZero() {\n      ctx = newCtx.WithMultiStore(ms)\n    }\n\n    if err != nil {\n      // error handling logic\n      return res\n    }\n\n    msCache.Write()\n  }\n  \n  // Main Handler\n  runMsgCtx, msCache := app.cacheTxContext(ctx)\n  result = app.runMsgs(runMsgCtx, msgs)\n  // BEGIN modification made in this ADR\n  if result.IsOK() || result.IsBreak() {\n  // END\n    msCache.Write()\n  }\n\n  return result\n}\n")),(0,r.kt)("p",null,"The Cosmos SDK will define an ",(0,r.kt)("inlineCode",{parentName:"p"},"AnteDecorator")," for IBC packet receiving. The\n",(0,r.kt)("inlineCode",{parentName:"p"},"AnteDecorator")," will iterate over the messages included in the transaction, type\n",(0,r.kt)("inlineCode",{parentName:"p"},"switch")," to check whether the message contains an incoming IBC packet, and if so\nverify the Merkle proof."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type ProofVerificationDecorator struct {\n  clientKeeper ClientKeeper\n  channelKeeper ChannelKeeper\n}\n\nfunc (pvr ProofVerificationDecorator) AnteHandle(ctx Context, tx Tx, simulate bool, next AnteHandler) (Context, error) {\n  for _, msg := range tx.GetMsgs() {\n    var err error\n    switch msg := msg.(type) {\n    case client.MsgUpdateClient:\n      err = pvr.clientKeeper.UpdateClient(msg.ClientID, msg.Header)\n    case channel.MsgPacket:\n      err = pvr.channelKeeper.RecvPacket(msg.Packet, msg.Proofs, msg.ProofHeight)\n    case chanel.MsgAcknowledgement:\n      err = pvr.channelKeeper.AcknowledgementPacket(msg.Acknowledgement, msg.Proof, msg.ProofHeight)\n    case channel.MsgTimeoutPacket:\n      err = pvr.channelKeeper.TimeoutPacket(msg.Packet, msg.Proof, msg.ProofHeight, msg.NextSequenceRecv)\n    case channel.MsgChannelOpenInit;\n      err = pvr.channelKeeper.CheckOpen(msg.PortID, msg.ChannelID, msg.Channel)\n    default:\n      continue\n    }\n\n    if err != nil {\n      return ctx, err\n    }\n  }\n  \n  return next(ctx, tx, simulate)\n}\n")),(0,r.kt)("p",null,"Where ",(0,r.kt)("inlineCode",{parentName:"p"},"MsgUpdateClient"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"MsgPacket"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"MsgAcknowledgement"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"MsgTimeoutPacket"),"\nare ",(0,r.kt)("inlineCode",{parentName:"p"},"sdk.Msg")," types correspond to ",(0,r.kt)("inlineCode",{parentName:"p"},"handleUpdateClient"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"handleRecvPacket"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"handleAcknowledgementPacket"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"handleTimeoutPacket")," of the routing module,\nrespectively."),(0,r.kt)("p",null,"The side effects of ",(0,r.kt)("inlineCode",{parentName:"p"},"RecvPacket"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"VerifyAcknowledgement"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"VerifyTimeout")," will be extracted out into separated functions,\n",(0,r.kt)("inlineCode",{parentName:"p"},"WriteAcknowledgement"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"DeleteCommitment"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"DeleteCommitmentTimeout"),", respectively,\nwhich will be called by the application handlers after the execution."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"WriteAcknowledgement")," writes the acknowledgement to the state that can be\nverified by the counter-party chain and increments the sequence to prevent\ndouble execution. ",(0,r.kt)("inlineCode",{parentName:"p"},"DeleteCommitment")," will delete the commitment stored,\n",(0,r.kt)("inlineCode",{parentName:"p"},"DeleteCommitmentTimeout")," will delete the commitment and close channel in case\nof ordered channel."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func (keeper ChannelKeeper) WriteAcknowledgement(ctx Context, packet Packet, ack []byte) {\n  keeper.SetPacketAcknowledgement(ctx, packet.GetDestPort(), packet.GetDestChannel(), packet.GetSequence(), ack)\n  keeper.SetNextSequenceRecv(ctx, packet.GetDestPort(), packet.GetDestChannel(), packet.GetSequence())\n}\n\nfunc (keeper ChannelKeeper) DeleteCommitment(ctx Context, packet Packet) {\n  keeper.deletePacketCommitment(ctx, packet.GetSourcePort(), packet.GetSourceChannel(), packet.GetSequence())\n}\n\nfunc (keeper ChannelKeeper) DeleteCommitmentTimeout(ctx Context, packet Packet) {\n  k.deletePacketCommitment(ctx, packet.GetSourcePort(), packet.GetSourceChannel(), packet.GetSequence())\n  \n  if channel.Ordering == types.ORDERED [\n    channel.State = types.CLOSED\n    k.SetChannel(ctx, packet.GetSourcePort(), packet.GetSourceChannel(), channel)\n  }\n}\n")),(0,r.kt)("p",null,"Each application handler should call respective finalization methods on the ",(0,r.kt)("inlineCode",{parentName:"p"},"PortKeeper"),"\nin order to increase sequence (in case of packet) or remove the commitment\n(in case of acknowledgement and timeout).\nCalling those functions implies that the application logic has successfully executed.\nHowever, the handlers can return ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"CodeTxBreak")," after calling those methods\nwhich will persist the state changes that has been already done but prevent any further\nmessages to be executed in case of semantically invalid packet. This will keep the sequence\nincreased in the previous IBC packets(thus preventing double execution) without\nproceeding to the following messages.\nIn any case the application modules should never return state reverting result,\nwhich will make the channel unable to proceed."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ChannelKeeper.CheckOpen")," method will be introduced. This will replace ",(0,r.kt)("inlineCode",{parentName:"p"},"onChanOpen*")," defined\nunder the routing module specification. Instead of define each channel handshake callback\nfunctions, application modules can provide ",(0,r.kt)("inlineCode",{parentName:"p"},"ChannelChecker")," function with the ",(0,r.kt)("inlineCode",{parentName:"p"},"AppModule"),"\nwhich will be injected to ",(0,r.kt)("inlineCode",{parentName:"p"},"ChannelKeeper.Port()")," at the top level application.\n",(0,r.kt)("inlineCode",{parentName:"p"},"CheckOpen")," will find the correct ",(0,r.kt)("inlineCode",{parentName:"p"},"ChennelChecker")," using the\n",(0,r.kt)("inlineCode",{parentName:"p"},"PortID")," and call it, which will return an error if it is unacceptable by the application."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ProofVerificationDecorator")," will be inserted to the top level application.\nIt is not safe to make each module responsible to call proof verification\nlogic, whereas application can misbehave(in terms of IBC protocol) by\nmistake."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ProofVerificationDecorator")," should come right after the default sybil attack\nresistant layer from the current ",(0,r.kt)("inlineCode",{parentName:"p"},"auth.NewAnteHandler"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// add IBC ProofVerificationDecorator to the Chain of\nfunc NewAnteHandler(\n  ak keeper.AccountKeeper, supplyKeeper types.SupplyKeeper, ibcKeeper ibc.Keeper,\n  sigGasConsumer SignatureVerificationGasConsumer) sdk.AnteHandler {\n  return sdk.ChainAnteDecorators(\n    NewSetUpContextDecorator(), // outermost AnteDecorator. SetUpContext must be called first\n    ...\n    NewIncrementSequenceDecorator(ak),\n    ibcante.ProofVerificationDecorator(ibcKeeper.ClientKeeper, ibcKeeper.ChannelKeeper), // innermost AnteDecorator\n  )\n}\n")),(0,r.kt)("p",null,"The implementation of this ADR will also create a ",(0,r.kt)("inlineCode",{parentName:"p"},"Data")," field of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Packet")," of type ",(0,r.kt)("inlineCode",{parentName:"p"},"[]byte"),", which can be deserialised by the receiving module into its own private type. It is up to the application modules to do this according to their own interpretation, not by the IBC keeper.  This is crucial for dynamic IBC."),(0,r.kt)("p",null,"Example application-side usage:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'type AppModule struct {}\n\n// CheckChannel will be provided to the ChannelKeeper as ChannelKeeper.Port(module.CheckChannel)\nfunc (module AppModule) CheckChannel(portID, channelID string, channel Channel) error {\n  if channel.Ordering != UNORDERED {\n    return ErrUncompatibleOrdering()\n  }\n  if channel.CounterpartyPort != "bank" {\n    return ErrUncompatiblePort()\n  }\n  if channel.Version != "" {\n    return ErrUncompatibleVersion()\n  }\n  return nil\n}\n\nfunc NewHandler(k Keeper) Handler {\n  return func(ctx Context, msg Msg) Result {\n    switch msg := msg.(type) {\n    case MsgTransfer:\n      return handleMsgTransfer(ctx, k, msg)\n    case ibc.MsgPacket:\n      var data PacketDataTransfer\n      if err := types.ModuleCodec.UnmarshalBinaryBare(msg.GetData(), &data); err != nil {\n        return err\n      }\n      return handlePacketDataTransfer(ctx, k, msg, data)\n    case ibc.MsgTimeoutPacket:\n      var data PacketDataTransfer\n      if err := types.ModuleCodec.UnmarshalBinaryBare(msg.GetData(), &data); err != nil {\n        return err\n      }\n      return handleTimeoutPacketDataTransfer(ctx, k, packet)\n    // interface { PortID() string; ChannelID() string; Channel() ibc.Channel }\n    // MsgChanInit, MsgChanTry implements ibc.MsgChannelOpen\n    case ibc.MsgChannelOpen: \n      return handleMsgChannelOpen(ctx, k, msg)\n    }\n  }\n}\n\nfunc handleMsgTransfer(ctx Context, k Keeper, msg MsgTransfer) Result {\n  err := k.SendTransfer(ctx,msg.PortID, msg.ChannelID, msg.Amount, msg.Sender, msg.Receiver)\n  if err != nil {\n    return sdk.ResultFromError(err)\n  }\n\n  return sdk.Result{}\n}\n\nfunc handlePacketDataTransfer(ctx Context, k Keeper, packet Packet, data PacketDataTransfer) Result {\n  err := k.ReceiveTransfer(ctx, packet.GetSourcePort(), packet.GetSourceChannel(), packet.GetDestinationPort(), packet.GetDestinationChannel(), data)\n  if err != nil {\n    // TODO: Source chain sent invalid packet, shutdown channel\n  }\n  k.ChannelKeeper.WriteAcknowledgement([]byte{0x00}) // WriteAcknowledgement increases the sequence, preventing double spending\n  return sdk.Result{}\n}\n\nfunc handleCustomTimeoutPacket(ctx Context, k Keeper, packet CustomPacket) Result {\n  err := k.RecoverTransfer(ctx, packet.GetSourcePort(), packet.GetSourceChannel(), packet.GetDestinationPort(), packet.GetDestinationChannel(), data)\n  if err != nil {\n    // This chain sent invalid packet or cannot recover the funds\n    panic(err)\n  }\n  k.ChannelKeeper.DeleteCommitmentTimeout(ctx, packet)\n  // packet timeout should not fail\n  return sdk.Result{}\n}\n\nfunc handleMsgChannelOpen(sdk.Context, k Keeper, msg MsgOpenChannel) Result {\n  k.AllocateEscrowAddress(ctx, msg.ChannelID())\n  return sdk.Result{}\n}\n')),(0,r.kt)("h2",{id:"status"},"Status"),(0,r.kt)("p",null,"Proposed"),(0,r.kt)("h2",{id:"consequences"},"Consequences"),(0,r.kt)("h3",{id:"positive"},"Positive"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Intuitive interface for developers - IBC handlers do not need to care about IBC authentication"),(0,r.kt)("li",{parentName:"ul"},"State change commitment logic is embedded into ",(0,r.kt)("inlineCode",{parentName:"li"},"baseapp.runTx")," logic")),(0,r.kt)("h3",{id:"negative"},"Negative"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Cannot support dynamic ports, routing is tied to the baseapp router")),(0,r.kt)("h3",{id:"neutral"},"Neutral"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Introduces new ",(0,r.kt)("inlineCode",{parentName:"li"},"AnteHandler")," decorator."),(0,r.kt)("li",{parentName:"ul"},"Dynamic ports can be supported using hierarchical port identifier, see #5290 for detail")),(0,r.kt)("h2",{id:"references"},"References"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Relevant comment: ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/cosmos/ics/issues/289#issuecomment-544533583"},"cosmos/ics#289")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/cosmos/ibc/tree/master/spec/core/ics-026-routing-module"},"ICS26 - Routing Module"))))}u.isMDXComponent=!0}}]);